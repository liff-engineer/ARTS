# [从最近读到的C++协程系列文章谈起](https://lewissbaker.github.io/)

这一系列文章是[cppcoro](https://github.com/lewissbaker/cppcoro)库作者写的关于C++中协程标准提案的讲解.17年有两篇,18年9月又有了一篇,印象中我第一次看到这系列文章时只写了两篇,读过,然后就忘记了内容......

直到最近,看到twitter上有人提及,就又重新花了时间读一遍,才得以有了一些理解.

## 文章内容

第一篇文章主要是拿协程和普通函数进行对比,将构成要素进行拆分,加上示例和图示进行讲解,基本上把协程讲解得比较清楚了.而且与普通函数得对比,能够加深我们对于函数调用实现的认识,如果你恰好以前做过嵌入式,搞过裸机程序和嵌入式系统,可能理解会更为透彻.

第二篇文章则侧重讲解了操作符`co_await`,第一篇文章已经将协程讲解得比较清楚了,如果你了解过纤程之类的概念,再看一看Boost的实现,这个协程对你来讲也就没什么神秘的.但是这篇文章将的内容不是说协程的实现,而是`Coroutines TS`到底涵盖了哪些内容? 我以前一直以为就是C++中新增了协程支持,实际上并非如此,`Coroutines TS`提供的是基础设施以及抽象,其中提供的机制能够支持库作者自定义协程行为,来供有能力者发挥自己的聪明才智来创造新的库和用法.抽象出来的是两种接口:`Promise`和`Awaitable`.而`co_await`则是作用在`Awaitable`之上.文中作者介绍了其扩展机制,并以示例来展示如何使用.

第三篇文章则讲解了`Promise`,文章中对`Promise`的描述是协程的行为实现者,三个协程操作符`co_await`、`co_yield`和`co_return`与协程的交互均由`Promise`定义.作者讲述了涉及协程中`Promsie`实现的方方面面,包含了构造、内存申请、传参、异常处理等等操作.通过这套扩展机制就可以自行实现自定义协程类型和行为.

后续还有相关内容的介绍,可能就要等几个月了.

## 我的思考

在之前,我对语言、特性、库的看法还是说去用,有可能去了解,从来没有接触过这样的文章,来去讲解一种编程语言特性的实现种种,涉及各种概念和抽象,并讲解其提供的扩展等机制.

经过这一年挖掘C++在项目中能够做得到不同应用,我已经有了更多的思考,遇到这系列文章之和,有种脑海中感受到一点点光亮的错觉,任何一种语言特性其设计的考量,莫不是对问题领域的深入挖掘和抽象,然后提供出来对应的解决方案,这对我来讲是从来未曾注意到的宝藏.我们去苦苦探索学习软件的设计、架构,去更深入地了解世界,了解面临的问题,是不是不曾想到有这么多“捷径”,能够直接跟随平时仰望的大神的脚步,来了解、学习和掌握这些方法和精髓?

如果我们的思考能够达到这样的深度,那么就能够发挥库、语言的最大能力,以更简洁、更强大的方式达成目标,库、语言、框架等等将不再是阻碍,也不会止步于使用,更多的是创造.

