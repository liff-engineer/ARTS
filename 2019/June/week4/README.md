# Weekly ARTS

- Python 中的修饰器
- 进行代码重构的一点儿感想

## Algorithm [目标和最短子数组问题](leetcode862.md)

## Review [Python 中的修饰器](decorator.md)

## Technique 数据库模型关系的设计

我们都知道数据库表中有主键和外键,而表与表之间存在着关系,譬如:

- 一对一关系
- 多对一关系
- 一对多关系
- 多对多关系

那么对应数据库中具体该如何设计呢?

### 一对一关系

假设两张表表达的为 A 和 B 两种数据,我们为 A 和 B 均设计了主键,A.PK 和 B.PK,我们知道 A.PK 与 B.PK 是一一映射的.具体该如何设计?

针对上述情况,应该将 B.PK 同时设计成 A.FK,即 B 的主键同时也是 A 的外键.这样 A 和 B 的主键完全一样.

### 多对一关系

假设有三张表 A,B,C,其中 C 对应了 A,B 两个表.即 C 的单条数据对应了 A,B 两个数据.

这时,表 C 中提供两个外键 A.FK1 和 A.FK2,分别对应于 A.PK 和 B.PK.

### 一对多关系

这种关系参考一对一关系的处理.

### 多对多关系

这种关系需要添加一个映射表.

## Share 进行代码重构的一点儿感想

这周都在"重构"一些代码,因为要在旧代码基上搞持续交付,必须对一些模块进行剥离,然后提供测试用例,之后才有可能去做持续交付.

我们的产品是 PC 端产品,所以能够积累的测试用例都是 UI 自动化.可以简单地理解为没有测试用例为重构保驾护航.

有几十万行代码,做重构是艰难的决定.团队是否支持你调整是最大的难点.好在我们已经在这个问题上达成共识. 接下来就是怎么做了.

产品用的是 C++,开发环境是 Visual Studio,之前没有用 CMake,工程配置随心所欲. 你不能说原先的代码没有考虑过解耦的问题,毕竟实现还是存放在单独的模块中.很不幸的是,我们提供的环境太自由了,自由到有大量本属于该模块的代码散布在代码基的各个角落.即使作为单独的模块,它所要求的不必要依赖也太多了.所以,我们启用了 Modern CMake,一方面用来支持,另一方面用来限制.为什么这样说,用了 Modern CMake,你能更轻松地引入某个依赖,同时也表明你能限制其依赖.

有了 Modern CMake 作为支撑,慢慢将模块拆分到非 UI 和 UI 两个模块,完成这一步之后,开始收缩向外提供的 API.接下来:

1. 移除无法独立运行的依赖
2. 提供运行环境
3. 整理 API
4. 提供测试用例

之后,该模块就可以走上持续交付的正规了.

学到了什么?

1. 不要恐惧,如果事情是正确的,那就去做
2. 要有好的工具,好的方法
3. 将每个功能模块作为库来开发、测试、交付(模块化开发)
