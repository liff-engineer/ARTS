# [尝试向面向对象死忠解释 ECS](https://medium.com/@icex33/ecs-for-die-hard-oo-developers-2a10cbc1f5db)

当你是一个面向对象死忠开发者,你应该会很熟悉依赖注入的概念.我并不只是指具体的依赖注入框架,我指的是这个概念,有时候被称为控制反转,或者好莱坞原则.

在面向对象中依赖注入主要用来解耦代码,使得其更易于进行单元测试,以及未来的演化.因为一些原因,大多数类都不能独立运转,它们依赖于其他类来持有数据或者暴露方法.这些其他类被称为依赖.

如果一个类可以自己创建它所依赖的类实例,它就变得透明或者无法进行配置.当我们遵循依赖注入原则,我们公开了类的依赖关系,使得它变得透明且可以被外部配置.

为了进一步减少对某一类的耦合,最好的实践方式是依赖于具体的接口或协议.这样可以向类提供不同的实现而不会引来大麻烦.这种技术带来了我之前说的,易于进行单元测试和未来的演化.

---

为了向面向对象死忠开发者解释,我需要一个面向对象的示例.让我们看一个计算面积的示例.这种示例经常被用在关于 SOLID 设计原则的教程中.

在一个典型的面向对象场景下,我们定义一个`Shape`接口或者协议,包含了`ComputeArea`方法.`ComputeArea`方法返回了计算结果.每个可以被视为形状的类(例如圆形、矩形、三角形)实现`Shape`并且提供自己的`ComputeArea`方法.

正如我之前提到的,在 ECS 中我们不以类的方式思考,我们以系统的方式思考.系统执行具体的变换.没有同样的形状系统.我们需要看一看手头的数据,然后搞清楚我们需要哪种系统来进行面积的计算.

对于圆形的面积,我们需要半径,于是对于所有带`Radius`组件的实体,需要提供`ComputeCircleAreaSystem`.

而对于那些拥有`Width`和`Height`组件的实体,需要的是`ComputeRectangleAreaSystem`.如果是包含`Base`和`Height`的实体,则需要`ComputeTriangleAreaSystem`.

我倾向于说在 ECS 中我们是从低向上的设计.我们审视数据,以及那些行为依赖于哪些数据.在面向对象中我们寻找抽象,通用的行为及定义.

---

现在作为一个面向对象死忠开发者,你可能不会想到另外一个问题.在 ECS 中系统是没有返回值的.在面向对象的方案中.我们定义通用的`ComputeArea`方法返回了计算结果.通常我们不是仅仅计算值,我们后续还需要对其进行处理.这意味着`ComputeArea`方法的结果会被存储到某些地方,或者传递给其他方法.

在 ECS 中,计算面积的系统,为实体添加`Area`组件信息.这意味着:

- `ComputeCircleAreaSystem`读取`Radius`组件,写入`Area`组件
- `ComputeRectangleAreaSystem`读取`Width`和`Height`.写入`Area`
- `ComputeTriangleAreaSystem`读取`Base`和`Height`.写入`Area`

---

假设我们需要计算所有区域的综合.为了做这个,我们需要定义系统`ComputeSumOfAllAreasSystem`.这个系统会获取所有包含`Area`组件的实体,对其求和,并存储结果到另外的组件中,或者产生副作用,例如打印到屏幕,或者通过网络发送结果.

---

正如你所看到的,使用 ECS 我们可以避免抽象.`ComputeSumOfAllAreasSystem`不依赖于包含`ComputeArea`方法的抽象`Shape`.它只依赖于`Area`组件/数据.它不在乎原始数据如何.面积值可以通过其他组件进行计算,也可以通过用户输入直接设置,或者从网络获取等等.

这是一种高度的解耦业务逻辑.能够做到易于单元测试,支撑未来的演化.

---

ECS 的目标和面向对象中依赖注入的目标非常类似.不同之处在于 ECS 是从低向上,而面向对象是从顶向下.
