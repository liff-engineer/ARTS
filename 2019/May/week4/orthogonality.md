# [Unix 编程艺术之紧凑性和正交性](http://www.faqs.org/docs/artu/ch04s02.html)

不是只有代码有最优化块大小.语言和 API(例如库或者系统调用)也具有同样的人类认知约束.

因此,在设计 API、命令集、协议等时,Unix 程序员已经学会了非常认真地考虑以下两个特性:紧凑性和正交性.

## 紧凑性

紧凑性意味着设计是否能够装进人类的头脑.有个很使用的紧凑性测试是:富有经验的用户是否需要手册? 如果不,那么设计(或者至少包含正常使用的子集)是紧凑的.

紧凑软件工具拥有物理工具的所有优点:非常顺手.让人乐于使用,不会在你的想法和工作之间格格不入.他们让你更高效-- 完全不像那些蹩脚的工具,还会将你弄伤.

紧凑不等于"薄弱".如果一个设计构建在易于理解且利于组合的抽象概念之上,它就能够具有非常强大、灵活的功能同时保持紧凑.紧凑也不等于"易于学习".某些紧凑设计非常难理解,直到你掌握了内部精巧的概念模型.一旦你理解了这些概念模型,整个视角都发生了变化,紧凑就会变得简单.对于大多数人而言,Lisp 编程语言就是一个典型的例子.

> 紧凑也不意味着"小".如果一个设计良好的系统对于有经验的用户来讲是可猜测,且"显而易见"的,它可能包含很多部分.

在绝对意义上来讲很少有软件的设计是紧凑的,但是放宽标准来看,有很多都是紧凑的.他们有紧凑的工作集,一个工作字集能够满足 80%的需求,或者专家用户通常使用的.实际上,这种设计通常指需要参考卡片或者备忘录,而不是手册.我们将这种设计称为半紧凑型,而不是严格紧凑型.

这个概念可能最好以示例说明.Unix 系统调用是半紧凑的,但是 C 标准库在任何意义上来讲都不是紧凑的.Unix 程序员可以使用很轻松地使用系统调用的子集来满足大多数应用程序编程(文件操作,信号,进程控制),这个子集完全可以记在脑海中.而 Unix 上的 C 语言库包含成百上千个条目,例如数学函数,一个程序员不可能把所有这些都记在脑中.

[The Magical Number Seven, Plus or Minus Two: Some Limits on Our Capacity for Processing Information](http://www.faqs.org/docs/artu/apb.html#Miller)是在认知心理学中的基础论文之一.它表明,人类在短期记忆中可以保留的离散信息数量为 7,加减 2.这给我们评测 API 紧凑性一个好的经验法则:程序员是否需要记住超过 7 个条目?超过 7 个则可以被视为不是严格紧凑的.

在 Unix 的工具中,make 是紧凑的,autoconf 和 automake 不是.在标记语言中,HTML 是半紧凑,但是 DocBook 不是.man 宏是紧凑的,但是 troff 不是的.

在通用编程语言中,C 和 Python 是半紧凑的;Perl、Java、Emacs Lips 以及 shell 不是.C++是反紧凑的 - 语言的设计者已经承认他不指望有任何程序员能够完全理解 C++.

有些设计不具备紧凑性,但是有足够的内部功能冗余,程序员通过选择语言的功能子集即可完成 80%的普通任务.Perl 就有这种伪紧凑性.这类设计有一个内部陷阱,当两个程序员试图就一个工程进行沟通,他们可能会发现由于选择的功能子集不一样,导致理解和修改代码时存在重大障碍.

但是,非紧凑设计并不总会导致灭亡或者糟糕.一些问题领域由于过于复杂,紧凑性设计无法覆盖.有时,为了其他优势,譬如性能或者适应范围,也有必要牺牲紧凑性.Troff 标记即是这样的例子.BSD 套接字也是如此.把紧凑性作为优点来强调,并不是要求大家将紧凑性视为必须满足的要求.而是要像 Unix 程序员那样:合理设计紧凑性,设计时尽可能考虑,而不是随意扔掉它.

## 正交性

正交性是有助于使复杂设计也能够紧凑的最重要特性之一.在纯正交设计中,操作没有副作用,每个动作(无论时 API 调用,宏调用还是语言操作)只会修改一件事情,并不影响到其它.无论你控制的是什么系统,有效且只有一个范式来修改每个属性.

显示器就是正交控制的.你可以修改亮度而不影响对比度,而颜色平衡控制于这两者也互相独立.想象一下,如果你调整一个修改亮度会影响颜色平衡的显示器设置,你必须在修改了亮度之后来调节颜色平衡.或者更严重的,想象一下如果对比度控制也会影响颜色平衡,那么要么改变对比度或颜色平衡保持其中一个不变,你必须严格按照正确的方法同时调节两个按钮.

目前有太多软件设计不是正交的.其中一个经常的设计错误,例如,发生在从某一格式读取并解析到另外一种格式.设计者认为源格式总是存储在硬盘文件上,可能会设计转换功能来打开和读取文件.但是输入也有可能就是一个文件句柄.如果转换例程以正交方式设计,例如,不会有打开文件等副作用,这就会在后续提供从标准输入、网络套接字或者其他源读取数据流来转换时节省大量工作.

Doug McIlroy"做好一件事"的建议通常被视为是针对简洁性的.但是,这句话也暗含了正交性至少同等重要的涵义.

如果程序做好一件事的同时,会产生其他副作用,只要副作用不会增加程序复杂性,不会导致容易出现漏洞,那么这并不是问题.在[第 9 章](http://www.faqs.org/docs/artu/generationchapter.html)我们会检视一个名为 ascii 的程序,用来打印 ASCII 字符的代名词,例如十六进制,八进制及二进制值.这存在的副作用就是它可以作为在 0 到 255 之间的数字的转换器.第二种用法并不违背正交性,因为这个特性对于主要的功能来讲是完全必须的.它并不会导致程序更难于文档化或者维护.

当副作用使得程序员或者用户的心智模型变得复杂化,容易被遗忘,导致结果从不方便到变得可怕,这时就会出现非正交性带来的问题.即使你不会忘记副作用,你通常需要做格外的工作来抑制或者解决它们.

在[The Pragmatic Programmer](http://www.faqs.org/docs/artu/apb.html#Hunt-Thomas)中有个关于正交性精彩的讨论,以及如何达到它.其中指出,正交性减少测试和开发视角,因为那些不会导致副作用或者依赖于其它代码的副作用的代码更容易验证,有更少的组合需要测试.如果它除了问题,正交代码可以很容易地替换掉而不影响系统的剩余部分.最终,正交代码在文档化和重用是会更容易.

重构的概念,这个最先出现在极限编程中的明确想法,与正交性密切相关.重构代码来改变它的结构和组织,同时不影响其可观察到的行为.自从该领域诞生以来,软件工程时一直这样做,但是命名并实践确定一套重构技术,则有效地帮人们集中了思路.因为重构概念与 Unix 设计传统关注的问题非常契合,Unix 开发者能够快速地吸收这一术语和其思想.

Unix 的 API 设计在正交性方面并不完美,但是也很成功.比如我们理所应当地认为打开一个文件都可以进行写入操作,而不需要锁定它,但并不是所有的操作系统都如此优雅.老式(System III)的信号就不是正交的,因为信号接收的副作用是重置信号处理为接收即崩溃.在 BSD 套接字 API 有大量非正交的补丁,还有更大规模的存在于 X 窗体系统绘制库中.

但是整个 Unix API 是良好的例子:否则,将不仅不会,也不可能这么广泛地被其他操作系统上的 C 库模仿.所以,即使不是 Unix 程序员,Unix API 也值得学习,因为可以从中学到一些关于正交性的东西.
